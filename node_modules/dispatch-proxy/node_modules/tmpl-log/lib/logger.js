var CLOSE_CODES, DEFAULT_TAGS, Logger, TagNode, TextNode, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ref = require('./const'), DEFAULT_TAGS = _ref.DEFAULT_TAGS, CLOSE_CODES = _ref.CLOSE_CODES;

TagNode = require('./node/tag');

TextNode = require('./node/text');

module.exports = Logger = (function() {
  function Logger(options) {
    var name, value, _base;
    if (options == null) {
      options = {};
    }
    this.format = __bind(this.format, this);
    this.emit = __bind(this.emit, this);
    this.log = __bind(this.log, this);
    this.options = {};
    for (name in options) {
      if (!__hasProp.call(options, name)) continue;
      value = options[name];
      this.options[name] = value;
    }
    this._tags = {};
    for (name in DEFAULT_TAGS) {
      value = DEFAULT_TAGS[name];
      this._tags[name] = value.slice(0);
    }
    this._events = {};
    this._modes = {};
    (_base = this.options).tab || (_base.tab = 6);
    if (!this.options.gutter && this.options.gutter !== '') {
      this.options.gutter = ' - ';
    }
    this.options.gutter = this.parse(this.options.gutter);
  }

  Logger.prototype.log = function(data, options) {
    var colors, depth, showHidden, _ref1;
    if (options == null) {
      options = {};
    }
    colors = options.colors, depth = options.depth, showHidden = options.showHidden;
    if (colors == null) {
      colors = true;
    }
    if (typeof data === 'string') {
      console.log(this.format(data));
    } else if ((_ref1 = typeof data) === 'object' || _ref1 === 'number') {
      console.log(util.inspect(data, {
        depth: depth,
        showHidden: showHidden,
        colors: colors
      }));
    } else {
      console.log(data);
    }
    return this;
  };

  Logger.prototype.emit = function(event, data) {
    var dataLine, dataLines, eventLine, eventLines, gutter, gutterSpace, i, line, output, tabsSpace, _i, _ref1;
    if ((this._mode != null) && this._modes[this._mode] !== true && (this._mode === false || __indexOf.call(this._modes[this._mode], event) < 0)) {
      return;
    }
    event = this._events[event] || (this.parse(event));
    data = this.format(data);
    output = [];
    dataLines = data.split('\n');
    eventLines = (function() {
      var _i, _ref1, _results;
      _results = [];
      for (i = _i = 0, _ref1 = Math.ceil(event.length / this.options.tab); 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        _results.push(event.slice(i * this.options.tab, (i + 1) * this.options.tab));
      }
      return _results;
    }).call(this);
    tabsSpace = (new Array(this.options.tab + 1)).join(' ');
    gutterSpace = (new Array(this.options.gutter.length + 1)).join(' ');
    gutter = this.options.gutter.style();
    for (i = _i = 0, _ref1 = Math.max(dataLines.length, eventLines.length); 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
      line = [];
      eventLine = eventLines[i];
      dataLine = dataLines[i];
      if (eventLine) {
        line.push((new Array(this.options.tab - eventLine.length + 1)).join(' '));
        line.push(eventLine.style());
      } else {
        line.push(tabsSpace);
      }
      line.push(i === 0 ? gutter : gutterSpace);
      line.push(dataLine);
      output.push(line.join(''));
    }
    console.log(output.join('\n'));
    return this;
  };

  Logger.prototype.format = function(str) {
    return (this.parse(str)).style();
  };

  Logger.prototype.parse = function(str) {
    var code, index, lastIndex, match, matchesLength, node, open, output, reg, root, tag, tree, _ref1;
    reg = /<\/?[a-zA-Z0-9-]*>/g;
    output = [];
    lastIndex = 0;
    matchesLength = 0;
    tree = [];
    root = new TagNode('root', {
      open: this._tags["default"].slice(0) || [],
      close: (function() {
        var _i, _ref1, _results;
        _ref1 = this._tags["default"];
        _results = [];
        for (_i = _ref1.length - 1; _i >= 0; _i += -1) {
          code = _ref1[_i];
          _results.push(CLOSE_CODES[code]);
        }
        return _results;
      }).call(this)
    });
    tree.unshift(root);
    while (match = reg.exec(str)) {
      _ref1 = match, match = _ref1[0], index = _ref1.index;
      if (str.slice(lastIndex, index) !== '') {
        tree[0].append(new TextNode(str.slice(lastIndex, index)));
      }
      lastIndex = index + match.length;
      open = match[1] !== '/';
      tag = open ? match.slice(1, -1) : match.slice(2, -1);
      if (open) {
        node = new TagNode(tag);
        tree[0].append(node);
        if (!(tag in this._tags)) {
          throw new Error("Non-existent style " + tag + " at index " + index);
        }
        node.appendCodes(this._tags[tag]);
        tree.unshift(node);
      } else {
        node = tree.shift();
        if (node.name !== tag && match !== '</>') {
          throw new Error("Expected </" + node.name + "> or </> closing tag, received </" + tag + "> instead at index " + index);
        }
      }
    }
    tree[0].append(new TextNode(str.slice(lastIndex)));
    return root;
  };

  Logger.prototype.setMode = function(mode) {
    if (!(mode in this._modes)) {
      throw new Error("Unknown mode (" + mode + ")");
    }
    this._mode = mode;
    return this;
  };

  Logger.prototype.registerMode = function(name, events) {
    if (name === 'default') {
      this._mode || (this._mode = name);
    }
    this._modes[name] = events;
    return this;
  };

  Logger.prototype.registerEvent = function(name, display) {
    this._events[name] = this.parse(display);
    return this;
  };

  Logger.prototype.registerTag = function(name, tags) {
    var tag, _ref1;
    this._tags[name] = (_ref1 = []).concat.apply(_ref1, (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tags.length; _i < _len; _i++) {
        tag = tags[_i];
        _results.push(this._tags[tag]);
      }
      return _results;
    }).call(this));
    return this;
  };

  return Logger;

})();

module.exports = Logger;
