var Dispatcher, SocksProxy, net, socks,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

net = require('net');

socks = require('socks-handler');

Dispatcher = require('../dispatcher');

module.exports = SocksProxy = (function(_super) {
  __extends(SocksProxy, _super);

  function SocksProxy(addresses, listenPort, listenHost) {
    var _this = this;
    SocksProxy.__super__.constructor.call(this, addresses);
    this.server = net.createServer(function(clientConnection) {
      return socks.handle(clientConnection, function(err, handler) {
        if (err) {
          _this.emit('socksError', err);
          return;
        }
        handler.on('error', function(err) {
          return this.emit('socksError', err);
        });
        return handler.on('request', function(_arg, callback) {
          var command, host, localAddress, onConnectError, port, serverConnection, version;
          version = _arg.version, command = _arg.command, host = _arg.host, port = _arg.port;
          if (command !== socks[5].COMMAND.CONNECT) {
            _this.emit('socksError', new Error("Unsupported command: " + command));
            if (version === 5) {
              callback(socks[5].REQUEST_STATUS.COMMAND_NOT_SUPPORTED);
            } else {
              callback(socks[4].REQUEST_STATUS.REFUSED);
            }
            return;
          }
          localAddress = _this.dispatch();
          serverConnection = net.createConnection({
            port: port,
            host: host,
            localAddress: localAddress
          });
          clientConnection.pipe(serverConnection).pipe(clientConnection);
          serverConnection.on('error', onConnectError = function(err) {
            var status;
            if (version === 5) {
              status = (function() {
                switch (err.code) {
                  case 'EHOSTUNREACH':
                    return socks[5].REQUEST_STATUS.HOST_UNREACHABLE;
                  case 'ECONNREFUSED':
                    return socks[5].REQUEST_STATUS.CONNECTION_REFUSED;
                  case 'ENETUNREACH':
                    return socks[5].REQUEST_STATUS.NETWORK_UNREACHABLE;
                  default:
                    return socks[5].REQUEST_STATUS.SERVER_FAILURE;
                }
              })();
            } else {
              status = socks[4].REQUEST_STATUS.FAILED;
            }
            return callback(status);
          }).on('connect', function() {
            var status;
            serverConnection.removeListener('error', onConnectError);
            status = version === 5 ? socks[5].REQUEST_STATUS.SUCCESS : socks[4].REQUEST_STATUS.GRANTED;
            return callback(status);
          }).on('end', function() {
            return _this.free(localAddress);
          });
          return _this.emit('request', {
             clientConnection:  clientConnection,
            serverConnection: serverConnection,
            host: host,
            port: port,
            localAddress: localAddress
          });
        });
      });
    });
    this.server.on('error', function(err) {
      return _this.emit('error', err);
    });
    this.server.listen(listenPort, listenHost);
  }

  return SocksProxy;

})(Dispatcher);
