var Dispatcher, EventEmitter,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

EventEmitter = require('events').EventEmitter;

module.exports = Dispatcher = (function(_super) {
  __extends(Dispatcher, _super);

  function Dispatcher(addresses) {
    this.addresses = addresses;
    this.free = __bind(this.free, this);
    this.connectionsTotal = 0;
    this.connectionsByAddress = {};
  }

  Dispatcher.prototype._prioritiesSum = function() {
    var priority;
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = this.addresses;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        priority = _ref[_i].priority;
        _results.push(priority);
      }
      return _results;
    }).call(this)).reduce(function(a, b) {
      return a + b;
    });
  };

  Dispatcher.prototype.dispatch = function() {
    var address, availableAddress, currentRatio, maxPriority, maxRatioDiff, prevailingAddress, priorityRatio, ratioDiff, _i, _len, _ref;
    availableAddress = null;
    prevailingAddress = null;
    maxRatioDiff = 0;
    maxPriority = 0;
    _ref = this.addresses;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      address = _ref[_i];
      currentRatio = (this.connectionsByAddress[address.address] / this.connectionsTotal) || 0;
      priorityRatio = address.priority / this._prioritiesSum();
      ratioDiff = priorityRatio - currentRatio;
      if (ratioDiff > maxRatioDiff) {
        maxRatioDiff = ratioDiff;
        availableAddress = address.address;
      }
      if (address.priority > maxPriority) {
        maxPriority = address.priority;
        prevailingAddress = address.address;
      }
    }
    if (maxRatioDiff < 0.000001) {
      this._increment(prevailingAddress);
      return prevailingAddress;
    } else {
      this._increment(availableAddress);
      return availableAddress;
    }
  };

  Dispatcher.prototype._increment = function(address) {
    var _base;
    (_base = this.connectionsByAddress)[address] || (_base[address] = 0);
    this.connectionsByAddress[address]++;
    return this.connectionsTotal++;
  };

  Dispatcher.prototype.free = function(address) {
    this.connectionsTotal--;
    if (--this.connectionsByAddress[address] === 0) {
      return delete this.connectionsByAddress[address];
    }
  };

  return Dispatcher;

})(EventEmitter);
